import 'BaseCS.ecore'
import '/resource/org.eclipse.ocl.pivot/model/Pivot.ecore'

package basecs

context  AnnotationCS
def: ast() : ocl::Annotation[1] = 
	ocl::Annotation {
		name = name,
		ownedDetails = ownedDetails.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedContents = ownedContents.ast()->asOrderedSet(),
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		references = ownedReferences.ast()->asOrderedSet()
	}

context AttributeCS
def: ast() : ocl::Property[1] = 
	ocl::Property {
		associationClass = null,
		defaultValueString = default,
		isComposite = false,
		isDerived = qualifiers->includes('derived'),
		isID = qualifiers->includes('id'),
		isImplicit = false,
		isReadOnly = qualifiers->includes('readonly'),
		isRequired = isRequired(),
		isResolveProxies = false,
		isStatic = qualifiers->includes('static'),
		isTransient = qualifiers->includes('transient'),
		isUnsettable = qualifiers->includes('unsettable'),
		isVolatile = qualifiers->includes('volatile'),
		keys = Set{}, 		-- FIXME
		name = name,
		opposite = null,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedExpression = if ownedDefaultExpressions->notEmpty()
							then ownedDefaultExpressions->first().ast()
							else null
							endif,
		redefinedProperties = Set{},
		referredProperty = null,
		subsettedProperty = null,
		type = ownedType.ast().oclAsType(ocl::Type)
	}

context /*abstract*/ ClassCS 
def : ast() : ocl::Class =
	null -- to be overridden
	
context ClassCS
def: ast() : ocl::Class[1] = invalid

-- FIXME stereotype, messageSpacification is not used
context ConstraintCS
def : ast() : ocl::Constraint[1] =
	ocl::Constraint {
		constrainedElements = OrderedSet{},	-- FIXME
		isCallable = false, -- FIXME
		name = name,
		ownedComments = getComments(),
		ownedSpecification = ownedSpecification.ast(),
		redefinedConstraints = Set{}
	}
	
context DataTypeCS 
def: ast() : ocl::DataType[1] =
	ocl::DataType {
		behavioralClass = null, 		-- FIXME
		instanceClassName = instanceClassName,
		isSerializable = isSerializable,
		name = name,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedInvariants = ownedConstraints.ast()->asSet(),
		ownedSignature = ownedSignature.ast(),
		superClasses = Set{ocl::OclElement}
	}

context DetailCS
def: ast() : ocl::Detail[1] = 
	ocl::Detail {
		name = name,
		ownedComments = getComments(),
		values = values->oclAsType(Sequence(String)[+|1])
	}
	
context ElementCS
/**
 * Comments do not form part of the grammar and so they may be recovered using implementation-specific
 * approaches that are simplified by the implementation here; no comments.
 */
def: getComments() : Set(ocl::Comment)[*|1] = Set(ocl::Comment){}
	
-- TODO: Obsolote. Remove from metamodel and/or grammar ?	
-- context DocumentationCS
--

--context ElementRefCS 

context EnumerationCS
def : ast() : ocl::Enumeration[1] =
	ocl::Enumeration {
		instanceClassName = instanceClassName,
		isSerializable = isSerializable,
		name = name,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedInvariants = ownedConstraints.ast()->asSet(),
		ownedLiterals = ownedLiterals.ast()->asOrderedSet(),
		ownedSignature = ownedSignature.ast(),
		superClasses = Set{ocl::OclElement}
	}

context EnumerationLiteralCS
def : ast() : ocl::EnumerationLiteral[1] =
	ocl::EnumerationLiteral {
		name = name,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		value = value
	}

--context	FeatureCS
context ImportCS
def : ast() : ocl::Import[1] =
	ocl::Import {
		importedNamespace = referredNamespace,
		-- importedNamespace = env().lookupNamespace(pathName)
		name = name,
		ownedComments = getComments()
	}


-- FIXME Study. This look like something for OclStdlib
-- Shouldn't the lambda be looked up in the environment?
context LambdaTypeCS 
def :  ast() : ocl::Type[1] =
	let type = 
		ocl::LambdaType {
			name = name,
			ownedParameterTypes = ownedParameterTypes.asParameterType()->asOrderedSet(),
			ownedResultType = ownedResultType.asParameterType()
		}
	in multiplicityType(type)

context ModelElementCS 
def : ast() : ocl::Element[1] =
	pivot

context ModelElementRefCS 
def : ast() : ocl::Element[1]  =
	-- FIXME element
	ownedPathName?.referredElement
	
-- FIXME what about the 'derived' qualifier ?
context OperationCS 
def : ast() : ocl::Operation[1] =
	ocl::Operation {
		bodyExpression = if ownedBodyExpressions->notEmpty() then ownedBodyExpressions->first().ast() else null endif,
--		isInvalidating = false,
		isStatic = qualifiers->includes( 'static'),
		isRequired = isRequired(),
		isTypeof = false,			-- FIXME
--		isValidating = false,
		name = name,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedParameters = ownedParameters.ast()->asOrderedSet(),
		ownedPostconditions = ownedPostconditions.ast()->asSet(),
		ownedPreconditions = ownedPreconditions.ast()->asSet(),
		ownedSignature = ownedSignature.ast(),
		precedence = null,
		raisedExceptions = ownedExceptions.ast()->asSet(),
		redefinedOperations = Set{},
		type = ownedType.ast()
	}

context PackageCS
def : ast() : ocl::Package[1] =
	ocl::Package{				
		importedPackages = Set{},
		name = name,
		nsPrefix = nsPrefix,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedClasses = ownedClasses.ast()->asSet(),
		ownedComments = getComments(),
		ownedInstances = Set{},
		ownedPackages = ownedPackages.ast()->asSet(),
		ownedProfileApplications = Set{},
		URI = nsURI
	}

-- context PackageOwnerCS
	
context ParameterCS 
def : ast() : ocl::Parameter[1] = 
	ocl::Parameter {
		isRequired = isRequired(),
		isTypeof = if ownedType.oclIsKindOf(TypedTypeRefCS) then ownedType.oclAsType(TypedTypeRefCS).isTypeof else false endif,
		name = name,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		type = ownedType.ast()
	}
	
context PathElementCS
def : ast() : ocl::Element = 
	referredElement 
	
-- context PathElementWithURICS

context PathNameCS 
def : ast() : ocl::Element =
	referredElement
	
context PivotableElementCS
def : ast() : ocl::Element =
	pivot

context PrimitiveTypeRefCS
def : ast() : ocl::Type[1] =
	let type =
		ocl::PrimitiveType {
			name = name,
			coercions = OrderedSet{}
		}
	in multiplicityType(type)

context ReferenceCS
def : ast() : ocl::Property[1] = 
	ocl::Property {
		associationClass = null,
		defaultValueString = default, -- default vs defaultExpressions ?
		isComposite = qualifiers->includes('composes'),
		isDerived = qualifiers->includes('derived'),
		isID = false,
		isImplicit = false,
		isReadOnly = qualifiers->includes('readonly'),
		isResolveProxies = qualifiers->excludes('!resolve'),
		isStatic = qualifiers->includes('static'),
		isTransient = qualifiers->includes('transient'),
		isUnsettable = qualifiers->includes('unsettable'),
		isVolatile = qualifiers->includes('volatile'),
		keys = referredKeys->asSet(), -- No idea what is this for
		name = name,
		opposite = if referredOpposite <> null
		 		   then referredOpposite
		 		   else ocl::Property {
								associationClass = null,
								defaultValueString = null,
								isComposite = false,
								isDerived = false,
								isID = false,
								isImplicit = true,
								isReadOnly = qualifiers->includes('readonly'),
								isRequired = false,
								isResolveProxies = qualifiers->excludes('!resolve'),
								isTransient = qualifiers->includes('transient'),
								isUnsettable = qualifiers->includes('unsettable'),
								isVolatile = qualifiers->includes('volatile'),
								keys = Set{},
								name = self.ast().owningClass?.name, -- FIXME hazard when having different types with same name => two properties with the same name
								opposite = ast(),
								ownedExpression = null,							
								owningClass = ownedType.ast(),							
								redefinedProperties = Set{},
								referredProperty = null,
								subsettedProperty = null
								-- FIXME how to statically define a collection of a dynamic Type  
								-- type = env().getCollectionType(ocl::CollectionKind::OrderedSet, thisType)
						}
					endif,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedExpression = if ownedDefaultExpressions->notEmpty()
							then ownedDefaultExpressions->first().ast()
							else null
							endif,
		redefinedProperties = Set{},
		referredProperty = null,
		subsettedProperty = null,
		type =	ownedType.ast()
	}
	

-- context RootCS

context RootPackageCS
def :ast() : ocl::Model[1] =
	ocl::Model {
		externalURI = null, -- FIXME csResource.getURI(), 
		ownedComments = getComments(),
		ownedImports = ownedImports.ast()->asOrderedSet(),
		ownedPackages = ownedPackages.ast()->asSet()
	}
 
context SpecificationCS
def : ast() : ocl::ExpressionInOCL[1] =
	ocl::ExpressionInOCL  {
		_'body' = exprString,
		language = 'OCL',
		ownedBody = null,
		ownedComments = getComments(),
		ownedContext = null,		-- FIXME compute me
		ownedParameters = null,		-- FIXME incompatible
		ownedResult = null
	}

context StructuredClassCS
def: ast() : ocl::Class[1] =
	ocl::Class {
		instanceClassName = instanceClassName,
		isAbstract = isAbstract,
		isInterface = isInterface,
		name = name,
		ownedAnnotations = ownedAnnotations.ast()->asOrderedSet(),
		ownedComments = getComments(),
		ownedInvariants = ownedConstraints.ast()->asSet(),
		ownedOperations = ownedOperations.ast()->asOrderedSet(),
		ownedProperties = ownedProperties.ast()->asOrderedSet(),
		ownedSignature = ownedSignature.ast(),
		superClasses = if ownedSuperTypes->isEmpty()
					 then Set(ocl::Class){ocl::OclElement}
					 else ownedSuperTypes.ast()->asSet()
					 endif
	}
	
context StructuralFeatureCS
def: ast() : ocl::Property[1] = invalid
	
context TemplateBindingCS
def : ast() : ocl::TemplateBinding[1] =
	let templateableClass = owningElement.ast().oclAsType(ocl::Class)
	in ocl::TemplateBinding {
		ownedSubstitutions = ownedSubstitutions.ast()->asSet()->oclAsType(Set(ocl::TemplateParameterSubstitution)[+|1]),
		templateSignature = templateableClass.unspecializedElement?.ownedSignature -- REF
				-- Possible loop with TypedTypeRefCS
	}
	
context TemplateParameterCS 
def : ast() : ocl::TemplateParameter[1] = invalid
	
context TemplateParameterSubstitutionCS
def : ast() : ocl::TemplateParameterSubstitution[1] = 
	let templateableClass = owningBinding?.owningElement.ast().oclAsType(ocl::Class)
	in ocl::TemplateParameterSubstitution {
		-- ownedActual. It looks like ownedActual is surplus
		actual = ownedActualParameter.ast(),
		formal = let elementPosition: Integer = owningBinding?.ownedSubstitutions->indexOf(self) 
				 in templateableClass.ownedSignature?.ownedParameters->at(elementPosition),
		ownedComments = getComments(),
		ownedWildcard = null		-- FIXME
	}
	
context TemplateSignatureCS
def : ast() : ocl::TemplateSignature[1] =
	ocl::TemplateSignature {
		ownedComments = getComments(),
		ownedParameters = ownedParameters.ast()->asOrderedSet()->oclAsType(OrderedSet(ocl::TemplateParameter)[+|1])
	}
	
context TuplePartCS
def : ast() : ocl::Property[1] = 
	ocl::Property {
		associationClass = null,
		defaultValueString = null,
		isComposite = false,
		isDerived = false,
		isID = false,
		isImplicit = true,
		isReadOnly = true,
		isRequired = isRequired(),
		isResolveProxies = false,
		isTransient = false,
		isUnsettable = false,
		isVolatile = false,
		keys = Set{},
		name = name,
		opposite = null,
		ownedExpression = null,							
		redefinedProperties = Set{},
		referredProperty = null,
		subsettedProperty = null,
		type = ownedType.ast()
	}
	
context TupleTypeCS
def : ast() : ocl::Type[1] =
	let type = 
		ocl::TupleType {
			name = name,
			ownedProperties = ownedParts.ast()->asSet()->sortedBy(name)
		}
	in multiplicityType(type)
	

context TypeParameterCS 
def : ast() : ocl::TemplateParameter[1] =
	ocl::TemplateParameter {
		constrainingClasses = ownedExtends.ast()->asSet(),		
		ownedComments = getComments()
	}

context TypedElementCS
def : isRequired() : Boolean[1] =
	let typeMultiplicity = ownedType?.ownedMultiplicity
	in
		if typeMultiplicity = null
		then false
		else
			if typeMultiplicity.getUpper() = 1 
			then typeMultiplicity.getLower() = 1
			else true
			endif
		endif
	
context TypeRefCS
def : ast() : ocl::Type =
	pivot.oclAsType(ocl::Type)
	
context TypedRefCS
def : ast() : ocl::Class =
	pivot.oclAsType(ocl::Class)
	
def : asParameterType() : ocl::ParameterType =
	ocl::ParameterType {
		type = ast(),
		isNonNull = isNonNull()
	}

def : isMultiple() : Boolean[1] = 
		ownedMultiplicity.getUpper() > 1

def : isNonNull() : Boolean[1] = 
		ownedMultiplicity <> null and ownedMultiplicity.getLower() > 0
		
def : multiplicityType(type : ocl::Type[1]) : ocl::Type[1] =
	if not isMultiple()
	then type
	else 
		let ordered = if oclContainer().oclIsKindOf(TypedElementCS)
					 	then oclContainer().oclAsType(TypedElementCS).qualifiers->includes('ordered')
					 	else false
					 	endif,
			unique = if  oclContainer().oclIsKindOf(TypedElementCS)
						then oclContainer().oclAsType(TypedElementCS).qualifiers->includes('unique')
						else false
						endif,
			superTypes = ocl::CollectionType {
							isNullFree = false,
							lower = null,
							name = 'Collection',
							elementType = type,
							superClasses = Set{ocl::OclAny},
							upper = null
						}.oclAsSet()
		in
			if unique
			then
				if ordered
				then ocl::OrderedSetType {
						name = 'OrderedSet',
						elementType = type,
						superClasses = superTypes
					}
				else ocl::SetType {
						name = 'Set',
						elementType = type,
						superClasses = superTypes
					}
				endif
			else 
				if ordered
				then ocl::SequenceType {
						name = 'Sequence',
						elementType = type,
						superClasses = superTypes
					}
				else ocl::BagType {
						name = 'Bag',
						elementType = type,
						superClasses = superTypes
					}
				endif
			endif
			
	endif

context TypedTypeRefCS
def : ast() : ocl::Type[1] =	
	let finalType : ocl::Type = 
		if ownedBinding = null
		then referredType
		else ocl::Class {
				name = referredType?.name,
				ownedBindings = ownedBinding.ast().oclAsSet(),
				unspecializedElement = referredType.oclAsType(ocl::Class)
			}
		endif
	in multiplicityType(finalType)

context WildcardTypeRefCS
def : ast() : ocl::Class =
	ocl::Class {
--		superClass = extends.ast()
	}
	
endpackage
