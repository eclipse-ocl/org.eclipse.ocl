/*******************************************************************************
 * Copyright (c) 2010, 2011 Willink Transformations and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v20.html
 *
 * Contributors:
 *   E.D.Willink - initial API and implementation
 * 	 E.D.Willink (Obeo) - Bug 416287 - tuple-valued constraints
 *******************************************************************************/
grammar org.eclipse.ocl.ocl3.xtext.essentialocl.OCLinEcore3 with org.eclipse.ocl.ocl3.xtext.essentialocl.EssentialOCL3

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.eclipse.ocl.ocl3/model/OCL3.ecore#//descriptors" as descriptors
import "platform:/resource/org.eclipse.ocl.ocl3/model/OCL3.ecore#//expressions" as expressions
import "platform:/resource/org.eclipse.ocl.ocl3/model/OCL3.ecore#//types" as types
import "platform:/resource/org.eclipse.ocl.ocl3/model/OCL3.ecore#//values" as values
//generate oclinEcore2 "http://www.eclipse.org/ocl/examples/xtext/oclinecore/OCLinEcore"

@Override 
Model returns types::Model:
	{types::Model} ('module' UnrestrictedName)?
	(ownedImports+=Import)*
	(ownedPackages+=Package)*
;

terminal UNQUOTED_STRING:	// Never forward parsed; just provides a placeholder
	'£$%^£$%^'				//  for reverse serialisation of embedded OCL 
;

INTEGER returns ecore::EInt:
	INT
;

SIGNED returns ecore::EInt:
	'-'? INT
;

EnumerationLiteralName returns ecore::EString:
	EssentialOCLUnrestrictedName
|	'abstract'
|	'attribute'
|	'body'
|	'callable'
|	'class'
|	'composes'
|	'datatype'
|	'definition'
|	'derivation'
|	'derived'
|	'enum'
|	'extends'
|	'id'
|	'import'
|	'initial'
|	'interface'
|	'key'
|	'library'
|	'module'
|	'operation'
|	'ordered'
|	'package'
|	'postcondition'
|	'precondition'
|	'primitive'
|	'property'
|	'readonly'
|	'reference'
|	'resolve'
|	'static'
|	'throws'
|	'transient'
|	'unique'
|	'unsettable'
|	'volatile'
;

InvariantConstraint returns types::Constraint:
	(isCallable?='callable')? stereotype='invariant' (name=UnrestrictedName ('(' ownedMessageSpecification=Specification ')')?)?
	((':' ownedSpecification=Specification? ';') | ';')
;

PostconditionConstraint returns types::Constraint:
	stereotype='postcondition' (name=UnrestrictedName ('(' ownedMessageSpecification=Specification ')')?)? ':' ownedSpecification=Specification? ';'
;

PreconditionConstraint returns types::Constraint:
	stereotype='precondition' (name=UnrestrictedName ('(' ownedMessageSpecification=Specification ')')?)? ':' ownedSpecification=Specification? ';'
;

Annotation returns types::Annotation:
	{types::Annotation} 'annotation' name=(UnrestrictedName|SINGLE_QUOTED_STRING)?
	('(' ownedDetails+=Detail (',' ownedDetails+=Detail)* ')')?
	(('{' (ownedAnnotations+=AnnotationElement
	     | ownedContents+=ModelElement
	     | ownedReferences+=ModelElementRef
	  )+'}')
	|';'
	)
;

AnnotationElement returns types::AnnotationElement:
	Annotation | Documentation | SysML
;

Attribute returns types::Attribute:
	((qualifiers+='static' (qualifiers+='definition')?) | (qualifiers+='definition' (qualifiers+='static')?))?
	'attribute' name=UnrestrictedName
	(':' ownedType=TypeWithMultiplicityDesc
	)?
	('=' default=SINGLE_QUOTED_STRING)?
	('{'((qualifiers+='derived' | qualifiers+='!derived' |
		  qualifiers+='id' | qualifiers+='!id' |
		  qualifiers+='ordered' | qualifiers+='!ordered' |
		  qualifiers+='readonly' | qualifiers+='!readonly' |
		  qualifiers+='transient' | qualifiers+='!transient' |
		  qualifiers+='unique' | qualifiers+='!unique' |
		  qualifiers+='unsettable' | qualifiers+='!unsettable' |
		  qualifiers+='volatile' | qualifiers+='!volatile'
	    ) ','? )+
	'}')?
	(	('{' (ownedAnnotations+=AnnotationElement
	      | ('initial' UnrestrictedName? ':' ownedDefaultExpressions+=Specification? ';') 
	      | ('derivation' UnrestrictedName? ':' ownedDefaultExpressions+=Specification? ';') )* '}')
	|	';'
	)
;

Class2 returns types::Class:
	Class | DataType | Enumeration
;

Class returns types::Class:
	isAbstract?='abstract'?
	'class' name=UnrestrictedName
	('<' ownedTemplateParameters+=TemplateParameter (',' ownedTemplateParameters+=TemplateParameter)* '>')?
	('extends' ownedSuperTypes+=TypeWithoutMultiplicityDesc (',' ownedSuperTypes+=TypeWithoutMultiplicityDesc)*)?
	(':' instanceClassName=SINGLE_QUOTED_STRING)?
	('{' isInterface?='interface'?
	 '}')?
	(	('{' (ownedAnnotations+=AnnotationElement
	        | ownedOperations+=Operation
	        | ownedProperties+=Property
	        | ownedConstraints+=InvariantConstraint)* '}')
	|	';'
	)
;

DataType returns types::DataType:
	isPrimitive ?= 'primitive'? 'datatype' name=UnrestrictedName
	('<' ownedTemplateParameters+=TemplateParameter (',' ownedTemplateParameters+=TemplateParameter)* '>')?
	(':' instanceClassName=SINGLE_QUOTED_STRING)?
	('{' (isSerializable?='serializable' | '!serializable')? '}')?
	(	('{' (ownedAnnotations+=AnnotationElement
	        | ownedConstraints+=InvariantConstraint)* '}')
	|	';'
	)
;

Detail returns types::Detail:
	name=(UnrestrictedName|SINGLE_QUOTED_STRING) '=' values+=(SINGLE_QUOTED_STRING|ML_SINGLE_QUOTED_STRING)*
;

Documentation returns types::Documentation:
	{types::Documentation} 'documentation' value=SINGLE_QUOTED_STRING?
	('(' ownedDetails+=Detail (',' ownedDetails+=Detail)* ')')?
	 ';'
;

Enumeration returns types::Enumeration:
	'enum' name=UnrestrictedName
	('<' ownedTemplateParameters+=TemplateParameter (',' ownedTemplateParameters+=TemplateParameter)* '>')?
	(':' instanceClassName=SINGLE_QUOTED_STRING)?
	('{' (isSerializable?='serializable' | '!serializable')? '}')?
	(	('{' (ownedAnnotations+=AnnotationElement
	        | ownedLiterals+=EnumerationLiteral
	        | ownedConstraints+=InvariantConstraint)* '}')
	| 	';'
	)
;

EnumerationLiteral returns types::EnumerationLiteral:
	(('literal' name=UnrestrictedName) | name=EnumerationLiteralName) (':' literal=SINGLE_QUOTED_STRING)? ('=' value=SIGNED)?
	(('{' ownedAnnotations+=AnnotationElement* '}')
	|';'
	)
;

Import returns types::Import:
	('import' | 'library') (name=UnrestrictedName ':')? ownedPathName=URIQualifiedName (isAll?='::*')? ';'
;

ModelElement returns types::ModelElement:
	Class2 | EnumerationLiteral | Operation | Package | Property
;

ModelElementRef returns descriptors::ModelElementDesc:
	'reference' ownedPathName=QualifiedNameDesc ';'
;

Operation returns types::Operation:
	((qualifiers+='static' (qualifiers+='definition')?) | (qualifiers+='definition' (qualifiers+='static')?))?
	'operation'
	('<' ownedTemplateParameters+=TemplateParameter (',' ownedTemplateParameters+=TemplateParameter)* '>')?
	name=UnrestrictedName
	'(' (ownedOperationParameters+=Parameter (',' ownedOperationParameters+=Parameter)*)? ')'
	(':' ownedType=TypeWithMultiplicityDesc)?
	('throws' ownedExceptions+=TypeWithoutMultiplicityDesc (',' ownedExceptions+=TypeWithoutMultiplicityDesc)*)?
	('{'((qualifiers+='derived' | qualifiers+='!derived' |
		  qualifiers+='ordered' | qualifiers+='!ordered' |
		  qualifiers+='transient' | qualifiers+='!transient' |
		  qualifiers+='unique' | qualifiers+='!unique'
		) ','? )+
	'}')?
	(	('{' (ownedAnnotations+=AnnotationElement
	        | ownedPreconditions+=PreconditionConstraint
	        | ('body' UnrestrictedName? ':' ownedBodyExpressions+=Specification? ';')
	        | ownedPostconditions+=PostconditionConstraint)* '}')
	|	';'
	)
;

Package returns types::Package:
	'package' name=UnrestrictedName
	(':' nsPrefix=UnrestrictedName)? ('=' nsURI=URI)?
	(('{'
		(ownedAnnotations+=AnnotationElement | ownedPackages+=Package | ownedClasses+=Class2)*
		'}')
	|';'
	)
;

Parameter returns types::Parameter:
	name=UnrestrictedName
	(':' ownedType=TypeWithMultiplicityDesc)?
	('{'(( qualifiers+='ordered' | qualifiers+='!ordered' |
		   qualifiers+='unique' | qualifiers+='!unique'
		  ) ','?)+
	 '}')?
	('{' ownedAnnotations+=AnnotationElement* '}')?
;

ImplicitOpposite returns types::ImplicitOpposite:
	'opposite' name=UnrestrictedName
	':' ownedType=TypeWithMultiplicityDesc
	('{'((qualifiers+='ordered' | qualifiers+='!ordered' |
		  qualifiers+='unique' | qualifiers+='!unique'
		) ','? )+
	'}')?
;

Reference returns types::Reference:
	((qualifiers+='static' (qualifiers+='definition')?) | (qualifiers+='definition' (qualifiers+='static')?))?
	'property' name=UnrestrictedName
	('#' referredOpposite=[types::Property|UnrestrictedName])?
	(':' ownedType=TypeWithMultiplicityDesc)?
	('=' default=SINGLE_QUOTED_STRING)?
	('{'((qualifiers+='composes' | qualifiers+='!composes' |
		  qualifiers+='derived' | qualifiers+='!derived' |
		  qualifiers+='ordered' | qualifiers+='!ordered' |
		  qualifiers+='readonly' | qualifiers+='!readonly' |
		  qualifiers+='resolve' | qualifiers+='!resolve' |
		  qualifiers+='transient' | qualifiers+='!transient' |
		  qualifiers+='unique' | qualifiers+='!unique' |
		  qualifiers+='unsettable' | qualifiers+='!unsettable' |
		  qualifiers+='volatile' | qualifiers+='!volatile'
		) ','? )+
	'}')?
	(	('{' (ownedAnnotations+=AnnotationElement
			| ('key' referredKeys+=[types::Property|UnrestrictedName] (',' referredKeys+=[types::Property|UnrestrictedName])* ';')
	        | ('initial' UnrestrictedName? ':' ownedDefaultExpressions+=Specification? ';') 
	        | ('derivation' UnrestrictedName? ':' ownedDefaultExpressions+=Specification? ';')
	        | (ownedImplicitOpposites+=ImplicitOpposite ';')
	        )* '}')
	|	';'
	)
;

Specification returns expressions::ExpSpecification:
	ownedExpression=Exp | exprString=UNQUOTED_STRING
;

Property returns types::Property:
	Attribute | Reference
;

SysML returns types::SysML:
	{types::SysML} 'sysml' ((ownedDetails+=Detail ';') | ('{' (ownedDetails+=Detail ';')* '}'))
;

TypeIdentifier:
	UnrestrictedName
|	PrimitiveTypeIdentifier
;

//TypedMultiplicityRef returns descriptors::TypedRef:
//	TypedRef (ownedMultiplicity=Multiplicity)?
//;

//---------------------------------------------------------------------------------
//	Base overrides
//---------------------------------------------------------------------------------
//TypedRef returns descriptors::TypedRef:
//	TypeLiteral | TypedTypeRef
//;

@Override 
UnrestrictedName returns ecore::EString:
	EnumerationLiteralName
|	'annotation'
|	'documentation'
|	'invariant'
|	'literal'
|	'opposite'
|	'serializable'
|	'sysml'
;
