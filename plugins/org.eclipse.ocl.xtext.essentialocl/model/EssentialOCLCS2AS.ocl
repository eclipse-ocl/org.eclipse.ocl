import 'EssentialOCLCS.ecore'
import '/resource/org.eclipse.ocl.xtext.base/model/BaseCS.ecore'
import '/resource/org.eclipse.ocl.pivot/model/Pivot.ecore'
import '/resource/org.eclipse.ocl.pivot/model/PivotCS2ASLookup.ocl'
import '/resource/org.eclipse.ocl.xtext.base/model/BaseCS2AS.ocl' -- To import other OCL definitions

import 'EssentialOCLCS2ASDisambiguation.ocl'
import 'EssentialOCLCS2ASHelpers.ocl'

package basecs

context ElementCS
def : elementParent : ElementCS =
	if oclContainer().oclIsKindOf(ElementCS)
	then oclContainer().oclAsType(ElementCS)
	else null
	endif
def : parent : basecs::ElementCS = elementParent

endpackage

package essentialoclcs

context BooleanLiteralExpCS
def : ast() : ocl::BooleanLiteralExp = 
	ocl::BooleanLiteralExp {
		booleanSymbol =	symbol.toBoolean(),
--		type = Boolean
		type = ast().lookupClass('Boolean')
	}
	
context CollectionLiteralExpCS 
def : ast() : ocl::CollectionLiteralExp =
	ocl::CollectionLiteralExp {
		kind = ocl::CollectionKind.allLiterals->any(name=ownedType.name),
		ownedParts = ownedParts.ast(),
		type = ownedType.ast()
	}

context CollectionLiteralPartCS
def : ast() : ocl::CollectionLiteralPart = 
	if isCollectionItem()
	then ocl::CollectionItem {
			ownedItem = ownedExpression.ast(),	
			type = ownedExpression.ast().oclAsType(ocl::OCLExpression).type
		}
	else if isCollectionRange() 
		then ocl::CollectionRange {
			ownedFirst = ownedExpression.ast(),
			ownedLast = ownedLastExpression.ast()
--			type = commonType(ownedExpression.ast().type, ownedLastExpression.ast().type)
		}
		else
			invalid
		endif
	endif

context CollectionTypeCS
def : ast() : ocl::CollectionType =	
	-- env().lookupCollectionType(name, ownedType)
	-- FIXME this should probably be a lookup
	ocl::CollectionType {
		name = name,
		elementType = ownedType.ast(),
		lower = if ownedMultiplicity = null
				then null
				else ownedMultiplicity.getLower()
				endif,
		upper = if ownedMultiplicity = null
				then null
				else 
					if ownedMultiplicity.getUpper() = -1
					then *
					else ownedMultiplicity.getUpper()
					endif
				endif
	}

-- FIXME probably move this to BaseCS.ocl
-- TODO 
--context basecs::ConstraintCS
--def : ast() : ocl::Constraint =
--	if messageSpecification = null
--	then basecs::ConstraintCS.ast()
--	else ocl::Constraint {
--		specification = ocl::ExpressionInOCL {
--			variable = ocl::VariableDeclaration {
--				name = 'self'
--			}	
--		}
--	} 
--	endif
	
	
-- TODO special context initializer
context ContextCS
def : ast() : ocl::ExpressionInOCL = 
	ocl::ExpressionInOCL {
		ownedBody = ownedExpression.ast()
	}

context ExpCS
--def : precedence : Precedence = LEAF_PRECEDENCE
def : isLocalLeftAncestorOf(csExp : ExpCS) : Boolean = false
def : isLocalRightAncestorOf(csExp : ExpCS) : Boolean = false
def : localLeft : ExpCS = self
def : localLeftmostDescendant : ExpCS = self
def : localParent : ExpCS = null
def : localRight : ExpCS = self
def : localRightmostDescendant : ExpCS = self
def : parent : basecs::ElementCS = if localParent <> null then localParent else elementParent endif

-- TODO there is a tricky part with respect to the case of having a messageExpression
context ExpSpecificationCS
def : ast() : ocl::ExpressionInOCL =
	if ownedExpression = null
	then ocl::ExpressionInOCL {
		language = 'OCL',
		_body = exprString
	}
	else ocl::ExpressionInOCL {
		language = 'OCL',
		ownedBody = ownedExpression.ast()
	}
	endif

context IfExpCS
def : ast() : ocl::IfExp =
	ocl::IfExp {
		ownedCondition = ownedCondition.ast(),
		ownedThen = ownedThenExpression.ast(),
		ownedElse = ownedElseExpression.ast()
--		type = commonType(ownedThenExpression.ast().type, ownedElseExpression.ast().ast)
--		isImplicit = isImplicit
	}
inv ElseIfHasBeenFlattened: ownedIfThenExpressions->isEmpty()
	
context InvalidLiteralExpCS
def : ast() : ocl::InvalidLiteralExp = 
	ocl::InvalidLiteralExp {
		type = OclInvalid
	}
	


context LetExpCS
def : ast() : ocl::LetExp = 
	ocl::LetExp {
		ownedVariable = ownedVariables->at(1).ast(),
		ownedIn = ownedInExpression.ast(),
--		isImplicit = isImplicit
		type = ownedInExpression.ast().oclAsType(ocl::OCLExpression).type
	}	
inv LetHasBeenFlattened: ownedVariables->size() = 1

context NameExpCS
def : ast() : ocl::OCLExpression =
	if isAssociationClassExp() then 
		ocl::AssociationClassCallExp {			
			name = referredAssociation.name, -- FIXME do a named-based lookup
--			type = specialized(referredAssociation.type),
			ownedSource = source.ast(),
			referredAssociationClass = referredAssociation -- FIXME do a named-based looku
--			isPre = isPre
		}
	else if isIterateExp() then
		ocl::IterateExp {
			name = referredIteration.name, -- FIXME do a named-based lookup
--			type = specialized(iteration.type),
			ownedSource = source.ast(),
			ownedIterators = iterators.ast(),
			ownedResult = accumulators->at(1).ast(),
			ownedBody = arguments->at(1).ast(),
			referredIteration = referredIteration -- FIXME do a named-based lookup
--			isPre = isPre
		}
	else if isIteratorExp() then 
		ocl::IteratorExp {
			name = referredIteration.name,
--			type = specialized(iteration.type),
			ownedSource = source.ast(),
			ownedIterators = iterators.ast(),
			ownedBody = arguments->at(1).ast(),
			referredIteration = referredIteration
--			isPre = isPre
		}
	else if isOperationCallExp() then 
		ocl::OperationCallExp {
			name = referredOperation.name, -- FIXME do a named-based lookup
--			type = specialized(referredOperation.type),
			ownedSource = source.ast(),
			ownedArguments = arguments.ast(),
			referredOperation = referredOperation, -- FIXME do a named-based lookup
			isPre = isPre
		}
	else if isPropertyCallExp() then 
		ocl::PropertyCallExp {
			name = referredProperty.name,
--			type = specialized(property.type),
			ownedSource = source.ast(),
			referredProperty = referredProperty
--			isPre = isPre
		}
	else if isShadowExp() then 
		ocl::ShadowExp {
			value = value,
			ownedParts = parts.ast()
--			type = env().lookupType(nameExp.pathName)
--			type = nameExp.ast().oclAsType(ocl::Type)
	}
	else if isVariableExp() then 
		ocl::VariableExp {
			name = referredVariable.name, -- FIXME do a named-based lookup
			type = referredVariable.type, -- FIXME do a named-based lookup
			referredVariable = referredVariable -- FIXME do a named-based lookup
		}
	else invalid
	endif endif endif endif endif endif endif

context NullLiteralExpCS
def : ast() : ocl::NullLiteralExp = 
	ocl::NullLiteralExp {
		type = OclVoid
	}
	
context NumberLiteralExpCS
def : ast() : ocl::NumericLiteralExp =
--	if symbol.floor() = symbol then 
		ocl::IntegerLiteralExp {
			-- integerSymbol = symbol--, FIXME
			-- type = Integer FIXME
		}
	
		
--	else 
--		ocl::RealLiteralExp {
--			realSymbol = symbol,
--			type = Real
--		}
--	endif 

context SelfExpCS
def :  ast() : ocl::VariableExp = 
	ocl::VariableExp {
		referredVariable = ast().lookupVariable(name), 
		type = ast().referredVariable.type 
	}
	
context ShadowPartCS
def : ast() :  ocl::ShadowPart =
	ocl::ShadowPart {
		ownedInit = ownedInitExpression.ast(),
		referredProperty = referredProperty -- REF Xtext cross-reference
	}
		
context StringLiteralExpCS
def : ast() : ocl::StringLiteralExp = 
	ocl::StringLiteralExp {
		stringSymbol = segments->iterate(x : String, result : String = '' |
						result = result.concat(x))--,
						-- type = String FIXME
	}
	
context TupleLiteralExpCS
def : ast() : ocl::TupleLiteralExp = 
	ocl::TupleLiteralExp {
		ownedParts = ownedParts.ast()
		-- type = env().lookupTuple(ownedParts)
	}

context TupleLiteralPartCS
def : ast() : ocl::TupleLiteralPart = 
	ocl::TupleLiteralPart {
		name = name,
		ownedInit = ownedInitExpression.ast(),
		type = ownedType.ast()
	}
	
context TypeLiteralExpCS
def : ast() : ocl::TypeExp =
	ocl::TypeExp {
		referredType = ownedType.ast(),
		type = ast().referredType
	}
	
-- TODO context UnaryOperatorCS
context UnlimitedNaturalLiteralExpCS
def : ast() : ocl::UnlimitedNaturalLiteralExp =
	ocl::UnlimitedNaturalLiteralExp{
		name = '*'
		-- unlimitedNaturalSymbol = ocl::_UnlimitedNatural{'*'} FIXME bug in AS2CG   
	}

context VariableCS
def : ast() : ocl::Variable = 
	ocl::Variable {
		name = name,
		ownedInit = ownedInitExpression.ast(),
		type = ownedType.ast()
	}

endpackage
