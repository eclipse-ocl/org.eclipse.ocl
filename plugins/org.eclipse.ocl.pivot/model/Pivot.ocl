import 'Pivot.ecore'

include 'Types.ocl'

package ocl

context Annotation
/** The names of the details of an Annotation must be distinct. */
inv DetailNamesAreUnique: ownedDetails->isUnique(detail | detail.name)

--context AssociationClass

--context AssociationClassCallExp

context BooleanLiteralExp
/** The type of a BooleanLiteralExp is the type Boolean. */
inv TypeIsBoolean: type = Boolean

context CollectionItem
/** True if this part excludes a null value, false if it includes a null value, null if indeterminate. */
def: isNullFree() : Boolean[?] = ownedItem.isNonNull()
/** The type of the item of a CollectionItem conforms to the type of the CollectionItem. */
inv CompatibleItemType: ownedItem.type.conformsTo(self.type)

context CollectionLiteralExp
/** Only collections of BagType type may have a Bag kind. */
inv BagKindIsBag: kind = CollectionKind::Bag implies type.oclIsKindOf(BagType)
/** 'Collection' is an abstract class on the M1 level and has no M0 instances. */
inv CollectionKindIsConcrete: kind <> CollectionKind::Collection
/** The type of every element must conform to the element type of the collection.  */
inv CompatibleElementType:
	let elementType = type.oclAsType(CollectionType).elementType
	in ownedParts->forAll(type.conformsTo(elementType))
-- The lowerbound is too hard to validate for dynamic or overlapping CollectionRanges  
--inv CompatibleLowerBound: parts->size() >= type.lower
/** A null free CollectionLiteral has no null values */
inv CompatibleNullFree:
	type.oclAsType(CollectionType).isNullFree implies 
	let nullFrees = ownedParts.isNullFree()
	in nullFrees->excludes(null) implies nullFrees->forAll(nf | nf)
/** The type of every element must conform to the element type of the collection.  */
inv CompatibleType: type.oclIsKindOf(CollectionType)
-- The upperbound is too hard to validate for dynamic or overlapping CollectionRanges  
--inv CompatibleUpperBound: parts->size() <= type.upper
/** Only collections of OrderedSetType type may have a OrderedSet kind. */
inv OrderedSetKindIsOrderedSet: kind = CollectionKind::OrderedSet implies type.oclIsKindOf(OrderedSetType)
/** Only collections of SequenceType type may have a Sequence kind. */
inv SequenceKindIsSequence: kind = CollectionKind::Sequence implies type.oclIsKindOf(SequenceType)
/** Only collections of SetType type may have a Set kind. */
inv SetKindIsSet: kind = CollectionKind::Set implies type.oclIsKindOf(SetType)

context CollectionLiteralPart
/** True if this part excludes a null value, false if it includes a null value, null if indeterminate. */
def: isNullFree() : Boolean[?] = invalid

context CollectionRange
/** True if this part excludes a null value, false if it includes a null value, null if indeterminate. */
def: isNullFree() : Boolean[?] = 
	if ownedFirst.isNonNull() = null or ownedLast.isNonNull() = null
	then null
	else ownedFirst.isNonNull() and ownedLast.isNonNull()
	endif
/** The type of the first item of a CollectionRange conforms to the type of the CollectionRange. */
inv CompatibleFirstType: ownedFirst.type.conformsTo(self.type)
/** The type of the last item of a CollectionRange conforms to the type of the CollectionRange. */
inv CompatibleLastType: ownedLast.type.conformsTo(self.type)

context EnumLiteralExp
/** The type of an EnumLiteralExp is the type of the referred literal. */
inv TypeIsEnumerationType: type = referredLiteral.owningEnumeration

context ExpressionInOCL
/** Return true if this TypedElement may have an OclInvalid type. By default TypedElements may not have an OclInvalid type */
def: mayHaveOclInvalidType() : Boolean[1] = ownedBody <> null and ownedBody.oclIsKindOf(InvalidLiteralExp)

/** Return true if this ExpressionInOCL has not yet been converted to Abstract Syntax form. */
def: mayHaveNullType() : Boolean[1] = ownedBody = null

context IfExp
/** The type of the else expression of an IfExp conforms to the IfExp type. */
inv CompatibleElseType: ownedElse.type.conformsTo(type)
/** The type of the then expression of an IfExp conforms to the IfExp type. */
inv CompatibleThenType: ownedThen.type.conformsTo(type)
/** The type of the condition of an IfExp is the type Boolean. */
inv ConditionTypeIsBoolean: ownedCondition.type = Boolean and typeValue = null

context IntegerLiteralExp
/** The type of an IntegerLiteralExp is the type Integer. */
inv TypeIsInteger: type = Integer

context InvalidLiteralExp
/** InvalidLiteralExps may have an OclInvalid type */
def: mayHaveOclInvalidType() : Boolean[1] = true

/** The type of an InvalidLiteralExp is the type OclInvalid. */
inv TypeIsOclInvalid: type = OclInvalid

context IterateExp
/** The type of an IterateExp is the type of the result variable. */
inv TypeIsResultType: ownedResult.type.conformsTo(self.type)

context LetExp
/** The type of the in expression of a LetExp conforms to the type of the LetExp. */
inv CompatibleInType: ownedIn.type.conformsTo(self.type)

context LiteralExp
/** True for a non-null value. NullLiteralExp overrides to return false. */
def: isNonNull() : Boolean[?] = true
/** The typeValue of a LiteralExp is null. */
inv TypeValueIsNull: typeValue = null

--context MessageExp
/** If the message is an operation call action, the arguments must conform to the parameters of the operation. */
--inv: calledOperation->notEmpty() implies
--argument->forAll (a | a.type.conformsTo
--(self.calledOperation.operation.ownedParameter->
--select( kind = ParameterDirectionKind::_'in' )
--->at (argument->indexOf (a)).type))

--context MessageExp
/** If the message is a send signal action, the arguments must conform to the attributes of the signal. */
--inv: sentSignal->notEmpty() implies
--argument->forAll (a | a.type.conformsTo
--(self.sentSignal.signal.ownedAttribute
--->at (argument->indexOf (a)).type))

--context MessageExp
/** If the message is a call operation action, the operation must be an operation of the type of the target expression. */
--inv: calledOperation->notEmpty() implies
--target.type.allOperations()->includes(calledOperation.operation)

context MessageExp
/** An OCL message has either a called operation or a sent signal. */
inv OneCallOrOneSend: ownedCalledOperation->size() + ownedSentSignal->size() = 1

context MessageExp
/** The target of an OCL message cannot be a collection. */
inv TargetIsNotACollection: not ownedTarget.type.oclIsKindOf(CollectionType)

context NamedElement
/** Return true if this NamedElement may have a null name. By default NamedElements may not have a null name */
def: mayHaveNullName() : Boolean[1] = false

context NullLiteralExp
/** False for a null value. */
def: isNonNull() : Boolean[?] = false
/** The type of a NullLiteralExp is the type OclVoid. */
inv TypeIsOclVoid: type = OclVoid

context OCLExpression
/** True if the rype of this expression prohibits a null value, otherwise null for indeterminate. */
def: isNonNull() : Boolean[?] = if self.isRequired then true else null endif

/** Return false since there is no need for OCLExpression's to have a name. */
def: mayHaveNullName() : Boolean[1] = false
/** */
context Operation
/** Operations may have a null return type */
def: mayHaveNullType() : Boolean[1] = true

inv CompatibleReturnType: bodyExpression <> null and bodyExpression.oclAsType(ExpressionInOCL).ownedBody <> null implies CompatibleBody(bodyExpression)

context OperationCallExp
/** All the arguments must conform to the parameters of the referred operation. */
inv ArgumentTypeIsConformant:
	let operation : Operation = self.referredOperation in
	let parameters : OrderedSet(Parameter) = operation.ownedParameters in
	let selfType : Type = operation.owningClass in
	Sequence{1..ownedArguments->size()}->forAll (i | 
		let argument : OCLExpression = ownedArguments->at(i) in
		let parameter : Parameter = parameters->at(i) in
		let parameterType : Type = parameter?.type in
		let requiredType : Type = if parameter?.isTypeof then Class else parameterType.specializeIn(self, selfType) endif in
		argument?.type.conformsTo(requiredType))

/** There must be exactly as many arguments as the referred operation has parameters. */
inv ArgumentCount: ownedArguments->size() = referredOperation.ownedParameters->size()
/** Safe navigation is not necessary when the source cannot be null. */

context Property
inv CompatibleDefaultExpressionType: ownedExpression <> null and ownedExpression.oclAsType(ExpressionInOCL).ownedBody <> null implies CompatibleBody(ownedExpression)

context RealLiteralExp
/** The type of a RealLiteralExp is the type Real. */
inv TypeIsReal: type = Real

context ShadowExp
inv AllPartsAreInitialized(
	let actualParts = ownedParts.referredProperty->asSet() in
	let formalParts = type.oclAsType(Class).ownedProperties in
	let nonDefaultParts = formalParts->select(
		(opposite <> null implies not opposite?.isComposite)
		and not isImplicit
		and not isDerived
		and defaultValueString = null
		and ownedExpression = null
		and if type.oclIsKindOf(CollectionType) then type.oclAsType(CollectionType).lower > 0 else isRequired endif
	) in
	let missingParts = nonDefaultParts->excludingAll(actualParts) in
	missingParts->iterate(p; acc : String = 'Missing initializer for ' | acc + ' ' + p.name)):
	let actualParts = ownedParts.referredProperty->asSet() in
	let formalParts = type.oclAsType(Class).ownedProperties in
	let nonDefaultParts = formalParts->select(
		(opposite <> null implies not opposite?.isComposite)
		and not isImplicit
		and not isDerived
		and defaultValueString = null
		and ownedExpression = null
		and if type.oclIsKindOf(CollectionType) then type.oclAsType(CollectionType).lower > 0 else isRequired endif
	) in
	let missingParts = nonDefaultParts->excludingAll(actualParts) in
	missingParts->isEmpty() 

context ShadowPart
inv CompatibleInitializerType: ownedInit.type.conformsTo(self.type)

context StringLiteralExp
/** The type of a StringLiteralExp is the type String. */
inv TypeIsString: type = String

context TupleLiteralPart
inv CompatibleInitializerType: ownedInit <> null implies ownedInit?.type.conformsTo(self.type)

context TypedElement
def: CompatibleBody(bodySpecification : ValueSpecification[1]) : Boolean[1] =
	bodySpecification.type.conformsTo(self.type)

/** Return true if this TypedElement may have a null type. By default TypedElements may not have a null type */
def: mayHaveNullType() : Boolean[1] = false

/** Return true if this TypedElement may have an OclInvalid type. By default TypedElements may not have an OclInvalid type */
def: mayHaveOclInvalidType() : Boolean[1] = false

/** Only TypedElements that mayHaveNullType() may have a null type */
inv TypeIsNotNull : not mayHaveNullType() implies type <> null

/** Only TypedElements that mayHaveOclInvalidType() may have an OclInvalid type */
inv TypeIsNotOclInvalid : not mayHaveOclInvalidType() implies type <> OclInvalid

context UnlimitedNaturalLiteralExp
/** The type of a UnlimitedNaturalLiteralExp is the type UnlimitedNatural. */
inv TypeIsUnlimitedNatural: type = UnlimitedNatural

context Variable
inv CompatibleInitializerType: ownedInit <> null implies ownedInit?.type.conformsTo(type)

--------------------------

context Constraint
inv UniqueName: true -- _'context'.ownedRule->excluding(self)->forAll(name <> self.name or stereotype <> self.stereotype)

context Element
def: allOwnedElements() : Set(Element) =
	self->closure(oclContents()->selectByKind(Element))

--FIXME oclContainer() suspect on DomainElements
--def: owner : Element = oclContainer()
	/**
	 * Elements that must be owned must have an owner.
	 */
--	inv has_owner:
--		mustBeOwned() implies owner->notEmpty() 
	/**
	 * An element may not directly or indirectly own itself.
	 */
--	inv not_own_self:
--		not allOwnedElements()->includes(self)

--	def: allOwnedElements() : Set(Element) =
--	ownedElement->union(ownedElement->collect(e | e.allOwnedElements()))->asSet()

--	def: mustBeOwned() : Boolean = true

--context ParameterableElement
--def: isCompatibleWith(p : ParameterableElement) : Boolean =
--p.oclIsKindOf(self.oclType())

context Type
def: flattenedType() : Type[?] = self

--context CollectionType
--def: flattenedType() : Type = elementType.flattenedType()

context Property
def: isAttribute(p : Property) : Boolean =
--Type.allInstances()->exists(c| c.ownedAttribute->includes(p))
let container : ocl::OclElement = oclContainer() in container.oclIsKindOf(Class) and container.oclAsType(Class).ownedProperties->includes(self)

--inv DerivedIsInitialized: isDerived implies ownedRule->one(stereotype = 'derivation') or ownedRule->one(stereotype = 'initial')

--inv CompatibleInitializer: isDerived implies defaultExpression <> null

context Operation
inv LoadableImplementation:
	true
inv UniquePreconditionName: ownedPreconditions->isUnique(p | p.name)
inv UniquePostconditionName: ownedPostconditions->isUnique(p | p.name)

context Class
inv UniqueInvariantName: ownedInvariants->isUnique(p | p.name)

context IteratorExp
inv ClosureBodyTypeIsConformanttoIteratorType:
	true
inv SortedByIteratorTypeIsComparable:
	true

--def: makeParameter() : Parameter = Parameter{name='name'}

---ExpressionWFRs.ocl-----

--context PropertyCallExp
/** The type of the call expression is the type of the referred property. */
--inv TypeIsReferredPropertyType: type = referredProperty.type

--context CollectionLiteralExp
/** The type of a collection literal expression is determined by the collection kind selection and the common
supertype of all elements. Note that the definition below defines only an upper bound on the elementType. The usage of
the CollectionLiteralExp defines a lower bound. If the elementType is not explicitly specified, the elementType must be
chosen to ensure the well-formedness of the elements of the CollectionLiteralExp and the usage of the
CollectionLiteralExp.

For instance in
acc : Set(Real) = Set{1}->excluding(-1)
Set{1} is well formed for any type Set(T) where T ≤ UnlimitedNatural. Well-formedness of the excluding operation call
requires T ≤ Integer, and well-formedness of the initializer requires Real ≤ T. The overall expression is therefore only
well-formed if Real ≤ T ≤ Integer. Either Set(Real) or Set(Integer) are well-formed. The most general type, Set(Real), is
recommended since it minimizes type conversions and can often be easily deduced by considering the result type.
*/
--inv ElementTypeIsCommonElementType: let elementType : Type = part->iterate (p; c : Classifier = OclVoid | c.commonSuperType (p.type))
--in elementType.conformsTo(type.oclAsType(CollectionType).elementType)

/* CollectionLiteralPart
No additional well-formedness rules. */

--context CollectionRange
/** The type of a CollectionRange is the common supertype of the expressions taking part in the range. */
--inv TypeIsCommonType: type = first.type.commonSuperType (last.type)

context IteratorExp
/** There is exactly one iterator. */
inv AnyHasOneIterator: name = 'any' implies ownedIterators->size() = 1

context IteratorExp
/** The type is the same as the source element type */
inv AnyTypeIsSourceElementType: name = 'any' implies type = ownedSource?.type?.oclAsType(CollectionType).elementType

context IteratorExp
/** The type of the body must be Boolean. */
inv AnyBodyTypeIsBoolean: name = 'any' implies ownedBody.type = 'Boolean'

context IteratorExp
/** There is exactly one iterator. */ 
inv ClosureHasOneIterator: name = 'closure' implies ownedIterators->size() = 1

context IteratorExp
/** The collection type for an OrderedSet or a Sequence source type is OrderedSet.
 * For any other source the collection type is Set. */
inv ClosureTypeIsUniqueCollection: name = 'closure' implies
if ownedSource?.type?.oclIsKindOf(SequenceType) or ownedSource?.type.oclIsKindOf(OrderedSetType) then
type.oclIsKindOf(OrderedSetType)
else
type.oclIsKindOf(SetType)
endif

context IteratorExp
/** The source element type is the same as type of the body elements or element. */
inv ClosureSourceElementTypeIsBodyElementType: name = 'closure' implies
ownedSource?.type.oclAsType(CollectionType).elementType =
if ownedBody.type.oclIsKindOf(CollectionType)
then ownedBody.type.oclAsType(CollectionType).elementType
else ownedBody.type
endif

context IteratorExp
/** The element type is the same as the source element type. */
inv ClosureElementTypeIsSourceElementType: name = 'closure' implies
type.oclAsType(CollectionType).elementType
= ownedSource?.type.oclAsType(CollectionType).elementType

context IteratorExp
/* The collection type for an OrderedSet or a Sequence type is a Sequence,
 * the result type for any other collection type is a Bag.
*/
inv CollectTypeIsUnordered: name = 'collect' implies
if ownedSource?.type.oclIsKindOf(SequenceType) or ownedSource?.type.oclIsKindOf(OrderedSetType) then
type.oclIsKindOf(SequenceType)
else
type.oclIsKindOf(BagType)
endif

context IteratorExp
/** The element type is the flattened type of the body elements. */
inv CollectElementTypeIsFlattenedBodyType: name = 'collect' implies
type.oclAsType(CollectionType).elementType = ownedBody.type.flattenedType()

context IteratorExp
/** The collection type for an OrderedSet or a Sequence type is a Sequence, the result type for any other collection type is Bag. */
inv SortedByIsOrderedIfSourceIsOrdered: name = 'sortedBy' implies
if ownedSource?.type.oclIsKindOf(SequenceType) or ownedSource?.type.oclIsKindOf(BagType) then
type.oclIsKindOf(SequenceType)
else
type.oclIsKindOf(OrderedSetType)
endif

context IteratorExp
/** The element type is the type of the body elements. */
inv SortedByElementTypeIsSourceElementType: name = 'sortedBy' implies
type.oclAsType(CollectionType).elementType =
ownedBody.type.oclAsType(CollectionType).elementType

context IterateExp
/** The type of the body expression must conform to the declared type of the result variable. */
inv BodyTypeConformsToResultType: ownedBody.type.conformsTo(ownedResult.type)

context IterateExp
/** A result variable must have an init expression. */
inv OneInitializer: self.ownedResult.ownedInit->size() = 1

/** LiteralExp
No additional well-formedness rules. */

context LoopExp
/** The type of the source expression must be a collection. */
inv SourceIsCollection: ownedSource?.type.oclIsKindOf(CollectionType)

context LoopExp
/** The loop variable of an iterator expression has no init expression. */
inv NoInitializers: self.ownedIterators->forAll(p | p.ownedInit->isEmpty())

context IteratorExp
/** The type of each iterator variable must be the type of the elements of the source collection. */
inv IteratorTypeIsSourceElementType: self.ownedIterators->forAll(p | ownedSource <> null implies ownedSource?.type.oclAsType(CollectionType).elementType.conformsTo(p.type))
/** Safe navigation is not necessary when the source collection is null-free. */
inv SafeSourceCanBeNull: isSafe implies not ownedSource?.type.oclAsType(CollectionType).isNullFree
/** Safe navigation is not necessary when an iterator can be null. */
inv SafeIteratorIsRequired: isSafe implies ownedIterators->forAll(isRequired)
/** Safe navigation is necessary when an iterator cannot be null and the source collection is not null-free. */
inv UnsafeSourceCanNotBeNull: (not isSafe and ownedIterators->exists(isRequired)) implies ownedSource?.type.oclAsType(CollectionType).isNullFree

context IterateExp
/** Safe navigation is not necessary when the source collection is null-free. */
inv SafeSourceCanBeNull: isSafe implies not ownedSource?.type.oclAsType(CollectionType).isNullFree
/** Safe navigation is not necessary when an iterator can be null. */
inv SafeIteratorIsRequired: isSafe implies ownedIterators->forAll(isRequired)
/** Safe navigation is necessary when an iterator cannot be null and the source collection is not null-free. */
inv UnsafeSourceCanNotBeNull: (not isSafe and ownedIterators->exists(isRequired)) implies ownedSource?.type.oclAsType(CollectionType).isNullFree

/** FeatureCallExp
No additional well-formedness rules. */

/** NumericLiteralExp
No additional well-formedness rules. */

/** OCLExpression
No additional well-formedness rules. */

context OperationCallExp
inv SafeSourceCanBeNull: (ownedSource <> null) and isSafe implies not ownedSource?.isRequired
/** Safe navigation is necessary when the source could be null. -- unless infix with an OclVoid overload */
--inv UnsafeSourceCanNotBeNull: (ownedSource <> null) and not isSafe implies ownedSource?.isRequired

--inv StaticSourceIsNull: referredOperation.isStatic implies source = null

--inv NonStaticSourceIsConformant: let operation : Operation = self.referredOperation in
--	not operation.isStatic implies source <> null --.type.conformsTo(operation.owningClass.specializeIn(self, operation.owningClass))


--context OperationCallExp
/** An additional attribute refParams lists all parameters of the referred operation except the return and out parameter(s). */
--def: refParams: Sequence(Parameter) = referredOperation.ownedParameter->select (p |
--p.kind <> ParameterDirectionKind::return or
--p.kind <> ParameterDirectionKind::out)

context PropertyCallExp
def: getSpecializedReferredPropertyOwningType() : Class = referredProperty.owningClass -- extended in Java code
def: getSpecializedReferredPropertyType() : Class = referredProperty.type.oclAsType(Class) -- extended in Java code
/** The type of the source conforms to the owning type of the property. */
inv NonStaticSourceTypeIsConformant: not referredProperty.isStatic implies 
	ownedSource?.type.conformsTo(getSpecializedReferredPropertyOwningType())
/** The type of the call expression is the type of the referred property. */
inv CompatibleResultType: type = getSpecializedReferredPropertyType()
/** Safe navigation is not necessary when the source cannot be null. */
inv SafeSourceCanBeNull: (ownedSource <> null) and isSafe implies not ownedSource?.isRequired
/** Safe navigation is necessary when the source could be null. */
inv UnsafeSourceCanNotBeNull: (ownedSource <> null) and not isSafe implies ownedSource?.isRequired

--inv StaticSourceIsNull: referredProperty.isStatic implies source.oclAsType(Type).conformsTo(getSpecializedReferredPropertyOwningType())

context Element
def: getValue(stereotype : Type, propertyName : String) : Element[?] = null

/*
context CompleteModel
def: allRootPackageURIs = partialRoots.ownedPackages.completeURI->asSet()
inv: packageURI2completeURI.keys = allRootPackageURIs
inv: completeURI2packageURIs.keys->forAll(c | completeURI2packageURIs[c]->forAll(p | packageURI2completeURI[p] = c))
inv: packageURI2completeURI.keys->forAll(p | completeURI2packageURIs[packageURI2completeURI[p]]->includes(p))






context CompleteModel
def: allRootPackages : Set(Package) = partialRoots.ownedPackages->asSet()		// no duplicates anyway
def: allRootPackageCompleteURIs = allRootPackages.completeURI->asSet()
inv: name2rootCompletePackage.keys = allRootPackageURIs
inv: name2rootCompletePackage.values = allRootPackages
inv: allRootPackageCompleteURIs->forAll(n | name2rootCompletePackage[n].partialPackages = allRootPackages->select(completeURI = n))






context CompletePackage
def: allNestedPackages : Set(Package) = partialPackages.ownedPackages->asSet()		// no duplicates anyway
def: allNestedPackageNames = allNestedPackages.name->asSet()
inv: name2nestedCompletePackage.keys = allNestedPackageNames
inv: name2nestedCompletePackage.values = allNestedPackages
inv: allNestedPackageNames->forAll(n | name2nestedCompletePackage[n].partialPackages = allNestedPackages->select(name = n))






context NestedCompletePackage
def: allPackages : Set(Package) = owningCompletePackage.partialPackages.ownedPackages->asSet()		// no duplicates anyway
def: allPackageNames = allPackages.name->asSet()
inv: name2completePackage.keys = allPackageNames
inv: name2completePackage.values = allPackages
inv: allPackageNames->forAll(n | name2completePackage[n].partialPackages = allPackages->select(name = n))






context CompleteClass
def: allClasses : Set(Class) = owningCompletePackage.partialPackages.ownedClasses->asSet()		// no duplicates anyway
def: allClassNames = allClasses.name->asSet()
inv: name2completeClass.keys = allClassNames
inv: name2completeClass.values = allClasses
inv: allClassNames->forAll(n | name2completeClass[n].partialClasses = allClasses->select(name = n))






context CompleteModel
def: allClasses : Set(Class) = partialRoots->closure(ownedPackages).ownedClasses
inv: allClasses->forAll(c | class2completeClass[c].partialClasses->includes(c))
inv: allClasses->size() = class2completeClass.values.partialClasses->size()
inv: allClasses->size() = class2completeClass.values.partialClasses->asSet()->size()
*/

endpackage
