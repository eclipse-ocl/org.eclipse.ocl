source  cs : '/resource/org.eclipse.ocl.xtext.base/model/BaseCS.ecore#/'
target  as : 'Pivot.ecore#/'

mappings {
	
}

disambiguation {
	
}

nameresolution {
		
	named-element NamedElement name-property name; 	  /*from target */
	name-referencer PathElementCS name-property name; /*from source */
	name-qualifier PathNameCS name-segments-property ownedPathElements; /*from source */
		
	Variable {
		named-element /*name-property name*/;
	}
	
	Namespace {
		named-element
			qualifies Namespace using none; -- derived namespaces will specify the qualification
	}
	
	/*FIXME Element {
		same-scope	
	}*/
	
	Behavior {	named-element; }
	
	Class {
		named-element 
		qualifies 
			Property, Namespace using ownedProperties,
			Operation, Namespace using ownedOperations;
						
		scopes-occluding
			Property, Namespace 
				using ownedProperties->select(not isStatic)
				occluding let allSuperClasses = self->closure(superClasses)
						 in allSuperClasses.ownedProperties->select(not isStatic)
			Operation, Namespace
				using ownedOperations->select(not isStatic)
				occluding let allSuperClasses = self->closure(superClasses)
						in allSuperClasses.ownedOperations->select(not isStatic)
			Behavior, Namespace
				using ownedBehaviors
				occluding let allSuperClasses = self->closure(superClasses)
						in allSuperClasses.ownedBehaviors;
						
		exports
			Operation 
				using ownedOperations->select(not isStatic)
				occluding let allSuperClasses = self->closure(superClasses)
						in allSuperClasses.ownedOperations->select(not isStatic);					
	}
	
	DataType {
		scopes-occluding 
			Property, Namespace 
				using ownedProperties->select(not isStatic)
				occluding let allSuperClasses = self->closure(superClasses)
						 in allSuperClasses.ownedProperties->select(not isStatic)
			Operation, Namespace
				using ownedOperations->select(not isStatic)
				occluding let allSuperClasses = self->closure(superClasses)
						in allSuperClasses.ownedOperations->select(not isStatic);
	}
	
	Enumeration {
		scopes-occluding 
			EnumerationLiteral using ownedLiterals
			Property using  ownedProperties->select(not isStatic)
			Operation using  ownedOperations->select(not isStatic)
			Behavior using ownedBehaviors;
		
	}
	
	EnumerationLiteral{ named-element; }
	
	ExpressionInOCL{
		scopes-occluding 
			Variable using ownedContext->asSequence() /*FIXME*/,
				ownedParameters,
				ownedResult->asSequence() /*FIXME*/;
		
	}
	
	IterateExp{
		for ownedIterators
			scopes-occluding 
				Variable using ownedResult->asSequence() /*FIXME*/, preceding ownedIterators;
		for all
			scopes-occluding 
				Variable using ownedIterators;
	}
	
	IteratorExp {
		for ownedIterators
			scopes-occluding 
				Variable using preceding ownedIterators;
		for all
			scopes-occluding 
				Variable using ownedIterators;
	}
	
	
	LetExp {
		for ownedIn
			scopes-occluding
				Variable using ownedVariable->asSequence() /*FIXME*/;
	}
	
	Library {
		scopes-occluding 
			Package using ownedPackages
			Class using	ownedClasses
			Precedence using ownedPrecedences;
	}
	
	Model {
		--named-element
		--	qualifies
		--	Package,Namespace using ownedPackages;
			
		scopes-occluding
			Package, Namespace using ownedPackages
			Namespace using ownedImports.importedNamespace
			-- NOT SUPPORTED YET , imported ownedImports.importedNamespace
			;
		
		exports 
			Package using ownedPackages;
	}
	
	Operation {
		named-element
			filtered by argTypes : OrderedSet(Type) 
				when matchesArgs(argTypes);
		for all excepting ownedParameters
			scopes-occluding 
				Variable using ownedParameters;
	}
	
	
	Package {
		named-element 
			qualifies Class, Namespace using ownedClasses, 
					   Package, Namespace using ownedPackages;
		/*for all*/
		scopes-occluding
			Class, Namespace using ownedClasses;
			
		exports 
			Class using ownedClasses
			Package using ownedPackages;
	}
		
	Precedence { named-element; }
	Property { named-element; }
}

helpers {
	as::Operation {
		matchesArgs(argTypes : OrderedSet(Type)) : Boolean :=
			argTypes->size() = ownedParameters->size() 
			and argTypes->forAll(x | x.conformsTo(ownedParameters->at(argTypes->indexOf(x)).type));
	}
	
	as::Class {
		conformsTo(anotherType : Class) : Boolean :=
			_conformsTo(anotherType) or 
			superClasses->exists(conformsTo(anotherType));

		_conformsTo(anotherType : Class) : Boolean :=
			self = anotherType;
	}
	
}